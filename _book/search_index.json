[
["index.html", "Random notes", " Random notes A random assortment of programming notes "],
["a-comparison-of-indexing-and-subsetting-in-r-and-python.html", "A comparison of indexing and subsetting in R and Python Dataframes Setup", " A comparison of indexing and subsetting in R and Python Dataframes In what follows we assume Python has access to a dataframe called mtcars which is constructed on the same basis as the R one. import pandas as pd mtcars = pd.read_csv(&quot;https://vincentarelbundock.github.io/Rdatasets/csv/datasets/mtcars.csv&quot;, index_col=0) Selecting rows Selecting row by numeric index R mtcars[1,] #Select row number 1 mtcars[c(1,2),] #Select row numbers 1 and 2 This returns a 'data.frame': 1 obs. of 11 variables or a 'data.frame': 2 obs. of 11 variables Python mtcars.iloc[0,:] #Select row number 1 (zero based indexing) mtcars.iloc[[0,1],:] #Select rows number 1 and 2. This returns a pandas.core.series.Series if you select a single row, or a pandas.core.frame.DataFrame if you select multiple rows. Selecting row by named index R mtcars[&#39;Mazda RX4&#39;, ] mtcars[c(&#39;Mazda RX4&#39;,&#39;Mazda RX4 Wag&#39;), ] This returns a 'data.frame': 1 obs. of 11 variables or a 'data.frame': 2 obs. of 11 variables Python mtcars.loc[&#39;Mazda RX4&#39;,:] mtcars.loc[[&#39;Mazda RX4&#39;, &#39;Mazda RX4 Wag&#39;],:] This returns a pandas.core.series.Series if you select a single row, or a pandas.core.frame.DataFrame if you select multiple rows. Selecting columns Selecting column by numeric index R mtcars[,1 ] mtcars[,c(1,2)] If we select a single column, this return an atomic vector. If we select multiple columns, it returns a 'data.frame': 32 obs. of 2 variables: Python mtcars.iloc[:,0] If we select a single column, this returns a pandas.core.series.Series. If we select multiple columns, it returns a pandas.core.frame.DataFrame. Selecting individual ‘cells’ (items) Selecting item by numeric index R mtcars[1,1 ] This returns a numeric vector with a single item Python mtcars.iloc[0,0] This returns a float Selecting item by named index R mtcars[&#39;Mazda RX4&#39;,&#39;mpg&#39;] This returns a numeric atomic vector with a single item. Python mtcars.loc[&#39;Mazda RX4&#39;,&#39;mpg] This returns a float. Selecting items with a logical vector It is possible to use a logical vector (a series of ‘truthy’ and ‘falsey’ values) to filter a dataframe. For instance, if your rows are 1,2,3 a logical vector true, false, true will select rows 1 and 3. R # The following df has 3 rows and 3 columns df &lt;- read.csv(&quot;https://gist.githubusercontent.com/RobinL/dae60170438c5e0adcd0c68fbaa6abdf/raw/62747b776c63c9bd367bcdc11fe7d6a3459eaa12/tiny.csv&quot;, row.names = 1) logical_vector &lt;- c(TRUE,FALSE, TRUE) df[logical_vector,] df[,logical_vector] logical_vector &lt;- c(TRUE, FALSE) df[logical_vector,] #This works due to R&#39;s vector recyclig df[,logical_vector] For more on vector recycling in R, see here. Python df = pd.read_csv(&quot;https://gist.githubusercontent.com/RobinL/dae60170438c5e0adcd0c68fbaa6abdf/raw/62747b776c63c9bd367bcdc11fe7d6a3459eaa12/tiny.csv&quot;, index_col=0) logical_vector = [True, False, True] df.loc[logical_vector,:] df.loc[:,logical_vector] logical_vector = [True, False] df.loc[logical_vector,:] #Different behaviour to R - no recycling df.loc[:,logical_vector] Obtaining the index itself R names(mtcars) rownames(mtcars) These are both atomic vectors of strings. Python mtcars.index mtcars.columns These are both of type pandas.indexes.base.Index Edge cases Things can get ambiguous in two situations: You have integer row or column names which aren’t just ascending integers starting at 0 (Python) or 1 (R). This creates an ambiguity between indexing my name or by number You have an index with duplicate values. Integer row/columns names which aren’t just 1,2,3…,n In R, row names are always strings, which resolves this ambiguity Data for these examples are here R df &lt;- read.csv(&quot;https://gist.githubusercontent.com/RobinL/7378abcb98d70f642a4047f4e01fd428/raw/5e26ef7581804308cd244a499737ead03eba66e8/f.csv&quot;, row.names = 1) df[c(1,2,3),] # Selects rows in positions 1,2,3 df[c(1,2,3,7),] # Selects rows in positions 1,2,3 and a blank row df[c(&quot;2&quot;,&quot;4&quot;,&quot;6&quot;),] # #Selects rows named &quot;2&quot;,&quot;4&quot;, and &quot;6&quot;&quot; corresponding to position 1, 2 and 3 df[c(&quot;2&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;),] # Row &quot;5&quot; does not exist, so it creates a blank row in the results Python df = pd.read_csv(&quot;https://gist.githubusercontent.com/RobinL/7378abcb98d70f642a4047f4e01fd428/raw/5e26ef7581804308cd244a499737ead03eba66e8/f.csv&quot;, index_col=0) df.iloc[[0,1,2],:] #Selects rows in position 1, 2 and 3 df.iloc[[0,1,2,6],:] #IndexError: positional indexers are out-of-bounds df.loc[[2,4,6],:] #Selects rows named 2,4, and 6 corresponding to position 0, 1 and 2 df.loc[[2,4,6,99],:] #Selects rows named 2,4, and 6 corresponding to position 0, 1 and 2, plus creates a row of NA with index 99 You can also use the pandas function ix for this, but I advise against it. See advice on the use of ix here. Duplicated row or column names Consider this table. R df &lt;- read.csv(&quot;https://gist.githubusercontent.com/RobinL/05eea0870961a80814da5ae22f25f407/raw/bd6f6cd2cf8edd22763e2afa460bf9a7c9bdd79b/tiny_dup.csv&quot;, row.names=1) #Error in read.table(file = file, header = header, sep = sep, quote = quote, : # duplicate &#39;row.names&#39; are not allowed Python df = pd.read_csv(&quot;https://gist.githubusercontent.com/RobinL/05eea0870961a80814da5ae22f25f407/raw/bd6f6cd2cf8edd22763e2afa460bf9a7c9bdd79b/tiny_dup.csv&quot;, index_col=0, mangle_dupe_cols=False) df.loc[2, &quot;b&quot;] # Returns 2 rows and 2 columns Writing to a dataframe Writing to individual ’cells In what follows I use name based indexing, but the following would also work with numeric (positional) indexing. R #Edit existing value mtcars[&quot;Mazda RX4&quot;, &quot;mpg&quot;] = 21.1 #Create new value mtcars[&quot;Future car&quot;, &quot;mpg&quot;] = 999 #A new row is created. All values are set to NA except for &#39;mpg&#39; column mtcars[&quot;Future car&quot;, &quot;mpg&quot;] = &quot;Not known&quot; #Note that this has the effect of coercing all the other values in the &#39;mpg&#39; column into a string vector. Python #Edit existing value mtcars.loc[&quot;Mazda RX4&quot;, &quot;mpg&quot;] = 21.1 #Create new value mtcars.loc[&quot;Future Car&quot;, &quot;mpg&quot;] = 999 #Note that this has the effect of coercing all the other values in the &#39;mpg&#39; column into a string vector. mtcars.loc[&quot;Future Car&quot;, &quot;mpg&quot;] = &quot;Not known&quot; #This does not affect the other values in the &#39;mpg&#39; column In the above I use ∞. This is the unicode string symbol for infinity. Note that in reality, R and Python both have a numeric concept of infinity: R has inf. Python has np.inf Subsetting Setup Here are some notes on running the code in this .Rmd. To run the code, you’ll want to remove eval=FALSE from the code blocks. In what follows we are going to use the mtcars dataset. If you want to run this code in Python, you’ll need access to the dataset. You can get this by doing: pip install ggplot and then in python from ggplot import mtcars Note that in order for the Python code to execute, you need to make sure that Sys.which('python') returns the path for Anaconda rather than Mac OS default python. See here, here and here. The solution I found was cd ~ echo .Renviron &gt;&gt; PATH=/Users/robinlinacre/anaconda/bin "]
]
